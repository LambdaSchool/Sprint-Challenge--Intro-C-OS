# How to write software

To write software if no operating system were present,To be able to write software for a computer, ironically enough, there already needs to be software in place.  If there is not then a few things need to be known before anything can be done. Some things can be assumed.

Firstly, since all CPU's have some type of instructions, you have to know the CPU instructions and the way in which the CPU is connected to and communicates with other components of a system.  You then need to know which components a system has.  CPUs receive instructions in a layered system.  The first layer that is not physically built into the system would be the BIOS.

BIOS is an acronym for Basic Input Output System.  The BIOS is almost always pre programmed firmware that the CPU looks for first.  It performs all hardware checks and initialization, stores that information and interacts with the CPU and OS at runtime.  Let's assume that the BIOS already exists.  The BOS then looks for the Bootloader, which would generally be in the first sector of the main disk accessible storage system.  The Boot Loader could even load a specific OS if it were programmed to do so from a list of OS choices!  This would be called the Boot Sector or Master Boot Record.  The BIOS then initiates the Bootloader.

The Bootloader's job is to do any basic preparation for the Operating System (OS) and then loads everything needed for the OS to load into memory.  This is where CPU instructions would come into play.  The Bootloader might be written in Assembly, which is then compiled into machine code instructions for that system.  It would need to have system-specific or general drivers, files that specify how to interact with the different peripherals and the components of the system.  Each of these would be written in either C or Assembly, most likely, and compiled to machine code and have to be able to communicate with the CPU in it's specific instruction set.  It would have to be able to read files from the storage medium and be able to communicate with the CPU and Memory to write to it.  The Bootloader then copies all required files that the either the OS or the programmer has specified to the Bootloader and what to do with them.  It copies those files and instructions into the system memory and then calls the entry point to that next layer or software.  We're still not logging in, though!

It's at this point that someone would have to have written an OS to load.  This might be the first user-facing piece of software on the machine.  At this level it could be written in any language that can be compiled efficiently into Assembly, which would then compile to machine code.  At every level, though, whatever code is written, it has to be compiled into machine code so that the CPU actually knows what to do with it.  At this point you would have a lot of code to write and there are very few shortcuts here.  You are communicating almost directly with the CPU so that the user does not have to.

All OS code has a few things in common.  It has to have enough code that it can load drivers for the different peripherals that it would be required to use at any time.  This would almost definitely be a user input device like a keyboard, mouse maybe, internal and external storage devices, output devices such as a screen, printer or some other output method and even some other connected device or system such as a NIC; A Network Interface Card.  All of these have drivers that have to be interacted with.  This requires lots of code.  At this point we are writing software.

All of this software code is written very specifically.  It has to be written with specific architecture and known drivers.   We are assuming a lot here.  It's also not written on the machine it's going to be run on, most likely.  It's written in another system that's already been made and then saved to some storage system that is compatible to the machine it will be loaded on.  We would have to write software to handle moving this newly-written OS software to the new machine's physical media storage.  This would require us to include some of those drivers and instructions to copy it to the physical media.  We would also have to have some way, usually through the Bootloader or a specific program that was instantiated at Boot time to run these install instructions.  At this time we could decide, based on the specs of the machine, what drivers and software to include on the new machine.

This is not user-created software in almost every case.  This would be taking input from the user based on the input devices, knowing what to do with it and knowing what to output.  Lots of input and output.  Lots of management and multitasking.  At this point, after writing tens of thousands of lines of code, we would have a basic text-based interface.  The user could type, the OS could output what the user typed.  We would even have instructions that could be invoked by the user and parsed by the OS.  If we wrote software that handled input, allowed users to save that input and then invoke that saved input as instructions, the OS could then run that code, giving instructions to the CPU and display output from the user-written code.

50 years later, we have a terminal.

I hope it was worth it..